import datetime
import os
import sys

import pefile
import peutils
import psutil
from signify.authenticode import AuthenticodeVerificationResult
from signify.authenticode import SignedPEFile

import const
import danger_statistic
from danger_statistic import ProcessStatisticInfo


class ProcessAnalysis:
    def __init__(self, check_exists=False):
        self.processes = []
        self.__init_processes(check_exists)

    def __init_processes(self, check_exists=False):
        print('[init process analysis...]')
        self.processes = psutil.pids()

        if check_exists:
            for pid in self.processes:
                try:
                    p = psutil.Process(pid)
                    print('  [process]:')
                    print(f'    [name]: {p.name()}\n    [pid]: {pid}')
                    pe = PE(p)
                    pe.analysis()
                except:
                    continue

    def check_new_process(self):
        try:
            now_process = psutil.pids()
            new_proc = set(set(now_process)).difference(self.processes)
            del_proc = set(set(self.processes)).difference(now_process)

            if len(new_proc) > 0:
                self.processes = set(self.processes).union(now_process)

                for pid in new_proc:
                    print('  [new process]:')
                    p = psutil.Process(pid)
                    print(f'    [name]: {p.name()}\n    [pid]: {pid}')
                    pe = PE(p)
                    pe.analysis()

            if len(del_proc) > 0:
                print('  [deleted processes]:')
                for pid in del_proc:
                    print(f'    [pid]: {pid}')
                self.processes = set(self.processes) - set(del_proc)
        finally:
            return

    # @staticmethod
    def check_new_process_hook(self, pid):
        try:
            process = psutil.Process(pid)
            pe = PE(process)
            pe.analysis()
        finally:
            return


class PE:
    def __init__(self, process, print_to_file=True):
        self.pid = process.pid
        self.process_name = process.name()
        self.pe = pefile.PE(process.exe())
        self.filename = process.exe()
        self.parent = process.parent().pid
        self.print_to_file = print_to_file
        self.output_file = sys.stdout
        self.statistic = ProcessStatisticInfo(pid=self.pid, filename=self.__format_filename())

    def analysis(self):
        try:
            if self.print_to_file:
                self.output_file = open(self.__format_filename(), 'w+')
            self.check_pid()
            self.check_parent()
            self.check_section()
            self.check_peid_signatures()
            self.check_imported_symbols()
            self.has_cert()
            danger_statistic.add(self.pid, self.statistic)
        finally:
            self.output_file.close()

    def check_pid(self):
        self.__print(f'[pid]: {self.pid}')

    def check_parent(self):
        self.__print(f'[parent pid]: {self.parent}')

    def check_section(self):
        self.__print('[section]:')
        for idx, section_entry in enumerate(self.pe.sections):
            name = section_entry.Name.decode('utf-8')
            self.__print('  [name]:', name)
            self.__print('    [characteristics]:')
            self.__parse_section_characteristic(section_entry.Characteristics, name)
            self.__print('    [md5]:', section_entry.get_hash_md5())
            self.__print('    [entropy]:', section_entry.get_entropy())

    def __parse_section_characteristic(self, characteristics, name):
        if characteristics & const.IMAGE_SCN_CNT_CODE:
            self.__print('      [-] section contains executable code')
        if characteristics & const.IMAGE_SCN_CNT_INITIALIZED_DATA:
            self.__print('      [-] section contains initialized data')
        if characteristics & const.IMAGE_SCN_CNT_UNINITIALIZED_DATA:
            self.__print('      [-] section contains uninitialized data')
        if characteristics & const.IMAGE_SCN_MEM_DISCARDABLE:
            self.__print('      [-] section can be discarded as needed')
        if characteristics & const.IMAGE_SCN_MEM_NOT_CACHED:
            self.__print('      [-] section cannot be cached')
        if characteristics & const.IMAGE_SCN_MEM_NOT_PAGED:
            self.__print('      [-] section cannot be paged')
        if characteristics & const.IMAGE_SCN_MEM_SHARED:
            self.__print('      [-] section can be shared in memory')
        if characteristics & const.IMAGE_SCN_MEM_EXECUTE:
            self.__print('      [-] section can be executed as code')
        if characteristics & const.IMAGE_SCN_MEM_READ:
            self.__print('      [-] section can be read')
        if characteristics & const.IMAGE_SCN_MEM_WRITE:
            self.__print('      [-] section can be written to')
        if (characteristics & const.IMAGE_SCN_MEM_EXECUTE) and \
                (characteristics & const.IMAGE_SCN_MEM_WRITE):
            self.__print('      [!] section is available for both write and execute')
            self.statistic.set_wx_section(name)
            print(f'    [!][{self.process_name}] contains section is available for both write and execute')

    def check_peid_signatures(self):
        self.__print('[pack]:')

        sig_path = os.path.join(os.getcwd() + "\\UserDB.TXT")
        with open(sig_path, 'rt') as f:
            sig_data = f.read()
            signatures = peutils.SignatureDatabase(data=sig_data)
        signs = signatures.match(self.pe, ep_only=True)

        if signs is None:
            self.statistic.set_has_peid(False)
            self.__print('  [-] not detected')
        else:
            self.statistic.set_has_peid(True)
            print(f'    [!][{self.process_name}] file may be packed')
            for s in signs:
                self.__print('  [!]', s)

    def check_imported_symbols(self):
        self.__print('[import]:')

        imports = []

        for entry in getattr(self.pe, "DIRECTORY_ENTRY_IMPORT", []):
            for imported_symbol in entry.imports:
                if imported_symbol.name is not None:
                    name = imported_symbol.name.decode("utf-8")
                    if name is not None and not name.startswith('_'):
                        imports.append(name)

        if len(imports) == 0:
            self.__print('  [-] no imported')
        else:
            for i in imports:
                if i in const.alerts:
                    print(f'    [!] imports \'{i}\'')
                    self.__print(f'  [!] {i}')
                else:
                    self.__print(f'  [-] {i}')

    def has_cert(self):
        self.__print('[signature]:')
        valid = False
        try:
            file_obj = open(self.filename, "rb")
            pe = SignedPEFile(file_obj)
            for signed_data in pe.signed_datas:
                if not valid:
                    valid = signed_data.explain_verify()[0] == AuthenticodeVerificationResult.OK
        finally:
            if not valid:
                self.__print('  [!] no certificate')
                self.statistic.set_has_valid_cert(False)
            else:
                self.statistic.set_has_valid_cert(True)
                self.__print('  [-] has valid certificate')

    def __print(self, *args):
        print(*args, file=self.output_file)

    def __format_filename(self):
        now = datetime.datetime.now()
        date = str(now.year) + str(now.month) + str(now.day)
        time = str(now.hour) + str(now.minute) + str(now.second)
        return 'analysis\\' + date + '_' + time + '_' + self.process_name + '_' + str(self.pid) + '.analysis'
