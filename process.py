import datetime
import json
import os
import sys
from builtins import print

import pefile
import peutils
import psutil
from colorama import Fore, Style
from signify.authenticode import AuthenticodeVerificationResult
from signify.authenticode import SignedPEFile

import const
from danger_statistic import ProcessStatisticInfo
from dump_diff import Dump, processing_queue


class ProcessAnalysis:
    @staticmethod
    def new_process(pid):
        try:
            p = psutil.Process(pid)
            if p.name() == 'pd64.exe' or p.name() == 'capa.exe' or p.parent().pid == os.getpid():
                return
            print(f'{Fore.GREEN}[new process]: {pid}, {p.name()}{Style.RESET_ALL}')
            pe = PE(p)
            os.mkdir(f'analysis\\{pid}')
            dump = Dump(pid)
            dump.get_dump()
            processing_queue.append([pid, pe, dump])
        finally:
            return

    @staticmethod
    def del_process(pid):
        try:
            print(f'{Fore.YELLOW}[deleted processes]: {pid}{Style.RESET_ALL}')
        finally:
            return


class PE:
    def __init__(self, process, print_to_file=True):
        self.pid = process.pid
        self.process_name = process.name()
        self.pe = pefile.PE(process.exe())
        self.filename = process.exe()
        self.parent = process.parent().pid
        self.print_to_file = print_to_file
        self.output_file = sys.stdout
        self.report = self.__report_filename()
        self.info = {const.PROC_NAME: self.process_name}
        self.statistic = ProcessStatisticInfo(pid=self.pid, filename=self.__format_filename())

    def analysis(self):
        try:
            if self.print_to_file:
                self.output_file = open(self.__format_filename(), 'w+')
            self.info[const.FILENAME] = self.filename
            self.check_pid()
            self.check_parent()
            self.check_section()
            self.check_peid_signatures()
            self.check_imported_symbols()
            self.has_cert()
            self.__print_report()
        finally:
            self.output_file.close()

        return self.info

    def check_pid(self):
        self.__print(f'[pid]: {self.pid}')
        self.info[const.PID] = self.pid

    def check_parent(self):
        self.__print(f'[parent pid]: {self.parent}')

    def check_section(self):
        self.__print('[section]:')
        number_of_wx = 0
        for idx, section_entry in enumerate(self.pe.sections):
            name = section_entry.Name.decode('utf-8')
            self.__print('  [name]:', name)
            self.__print('    [characteristics]:')
            if self.__parse_section_characteristic(section_entry.Characteristics, name):
                number_of_wx += 1
            self.__print('    [md5]:', section_entry.get_hash_md5())
            self.__print('    [entropy]:', section_entry.get_entropy())
        self.info[const.WX_SECTION] = number_of_wx

    def __parse_section_characteristic(self, characteristics, name):
        if characteristics & const.IMAGE_SCN_CNT_CODE:
            self.__print('      [-] section contains executable code')
        if characteristics & const.IMAGE_SCN_CNT_INITIALIZED_DATA:
            self.__print('      [-] section contains initialized data')
        if characteristics & const.IMAGE_SCN_CNT_UNINITIALIZED_DATA:
            self.__print('      [-] section contains uninitialized data')
        if characteristics & const.IMAGE_SCN_MEM_DISCARDABLE:
            self.__print('      [-] section can be discarded as needed')
        if characteristics & const.IMAGE_SCN_MEM_NOT_CACHED:
            self.__print('      [-] section cannot be cached')
        if characteristics & const.IMAGE_SCN_MEM_NOT_PAGED:
            self.__print('      [-] section cannot be paged')
        if characteristics & const.IMAGE_SCN_MEM_SHARED:
            self.__print('      [-] section can be shared in memory')
        if characteristics & const.IMAGE_SCN_MEM_EXECUTE:
            self.__print('      [-] section can be executed as code')
        if characteristics & const.IMAGE_SCN_MEM_READ:
            self.__print('      [-] section can be read')
        if characteristics & const.IMAGE_SCN_MEM_WRITE:
            self.__print('      [-] section can be written to')
        return (characteristics & const.IMAGE_SCN_MEM_EXECUTE) and \
               (characteristics & const.IMAGE_SCN_MEM_WRITE)

    def check_peid_signatures(self):
        self.__print('[pack]:')
        sig_path = os.path.join(os.getcwd() + "\\UserDB.TXT")
        with open(sig_path, 'rt') as f:
            sig_data = f.read()
            signatures = peutils.SignatureDatabase(data=sig_data)
        signs = signatures.match(self.pe, ep_only=True)

        if signs is None:
            self.statistic.set_has_peid(False)
            self.__print('  [-] not detected')
        else:
            self.statistic.set_has_peid(True)
            print(f'    [!][{self.process_name}] file may be packed')
            for s in signs:
                self.__print('  [!]', s)
        self.info[const.PACK] = signs is not None

    def check_imported_symbols(self):
        self.__print('[import]:')

        imports = []

        for entry in getattr(self.pe, "DIRECTORY_ENTRY_IMPORT", []):
            for imported_symbol in entry.imports:
                if imported_symbol.name is not None:
                    name = imported_symbol.name.decode("utf-8")
                    if name is not None and not name.startswith('_'):
                        imports.append(name)

        if len(imports) == 0:
            self.__print('  [-] no imported')
        else:
            for i in imports:
                if i in const.alerts:
                    print(f'    [!] imports \'{i}\'')
                    self.__print(f'  [!] {i}')
                else:
                    self.__print(f'  [-] {i}')

    def has_cert(self):
        self.__print('[signature]:')
        valid = False
        try:
            file_obj = open(self.filename, "rb")
            pe = SignedPEFile(file_obj)
            for signed_data in pe.signed_datas:
                if not valid:
                    valid = signed_data.explain_verify()[0] == AuthenticodeVerificationResult.OK
        except Exception as e:
            print(e)
        finally:
            if not valid:
                self.__print('  [!] no certificate')
                self.statistic.set_has_valid_cert(False)
            else:
                self.statistic.set_has_valid_cert(True)
                self.__print('  [-] has valid certificate')
            self.info[const.HAS_VALID_CERT] = valid

    def __print(self, *args):
        print(*args, file=self.output_file)

    def __print_report(self):
        with open(self.report, "a") as convert_file:
            convert_file.write(json.dumps(self.info))
            convert_file.close()

    def __format_filename(self):
        now = datetime.datetime.now()
        date = str(now.year) + str(now.month) + str(now.day)
        time = str(now.hour) + str(now.minute) + str(now.second)
        return 'analysis\\' + str(self.pid) + '\\' + date + '_' + time + '_' + self.process_name + '_' + str(
            self.pid) + '.analysis'

    def __report_filename(self):
        return f'report\\info\\{self.pid}'
